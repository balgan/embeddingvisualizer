{"ast":null,"code":"import { Matrix, MatrixTransposeView, EVD, SVD, NIPALS } from 'ml-matrix';\n/**\n * Creates new PCA (Principal Component Analysis) from the dataset\n * @param {MaybeMatrix} dataset - dataset or covariance matrix.\n * @param {PCAOptions} [options]\n * @param {boolean} [options.isCovarianceMatrix=false] - true if the dataset is a covariance matrix.\n * @param {string} [options.method='SVD'] - select which method to use: SVD (default), covarianceMatrirx or NIPALS.\n * @param {number} [options.nCompNIPALS=2] - number of components to be computed with NIPALS.\n * @param {boolean} [options.center=true] - should the data be centered (subtract the mean).\n * @param {boolean} [options.scale=false] - should the data be scaled (divide by the standard deviation).\n * @param {boolean} [options.ignoreZeroVariance=false] - ignore columns with zero variance if `scale` is `true`.\n * */\nexport class PCA {\n  constructor(dataset, options = {}, model) {\n    /* eslint-disable @typescript-eslint/naming-convention */\n    this.U = null;\n    this.S = null;\n    if (model) {\n      this.center = model.center;\n      this.scale = model.scale;\n      this.means = model.means;\n      this.stdevs = model.stdevs;\n      this.U = Matrix.checkMatrix(model.U);\n      this.S = model.S;\n      this.R = model.R;\n      this.excludedFeatures = model.excludedFeatures || [];\n      return;\n    }\n    let datasetMatrix;\n    if (Array.isArray(dataset)) {\n      datasetMatrix = new Matrix(dataset);\n    } else {\n      datasetMatrix = new Matrix(dataset);\n    }\n    const {\n      isCovarianceMatrix = false,\n      method = 'SVD',\n      nCompNIPALS = 2,\n      center = true,\n      scale = false,\n      ignoreZeroVariance = false\n    } = options;\n    this.center = center;\n    this.scale = scale;\n    this.means = null;\n    this.stdevs = null;\n    this.excludedFeatures = [];\n    if (isCovarianceMatrix) {\n      // User provided a covariance matrix instead of dataset.\n      this._computeFromCovarianceMatrix(datasetMatrix);\n      return;\n    }\n    this._adjust(datasetMatrix, ignoreZeroVariance);\n    switch (method) {\n      case 'covarianceMatrix':\n        {\n          // User provided a dataset but wants us to compute and use the covariance matrix.\n          const covarianceMatrix = new MatrixTransposeView(datasetMatrix).mmul(datasetMatrix).div(datasetMatrix.rows - 1);\n          this._computeFromCovarianceMatrix(covarianceMatrix);\n          break;\n        }\n      case 'NIPALS':\n        {\n          this._computeWithNIPALS(datasetMatrix, nCompNIPALS);\n          break;\n        }\n      case 'SVD':\n        {\n          const svd = new SVD(datasetMatrix, {\n            computeLeftSingularVectors: false,\n            computeRightSingularVectors: true,\n            autoTranspose: true\n          });\n          this.U = svd.rightSingularVectors;\n          const singularValues = svd.diagonal;\n          const eigenvalues = [];\n          for (const singularValue of singularValues) {\n            eigenvalues.push(singularValue * singularValue / (datasetMatrix.rows - 1));\n          }\n          this.S = eigenvalues;\n          break;\n        }\n      default:\n        {\n          throw new Error(`unknown method: ${method}`);\n        }\n    }\n  }\n  /**\n   * Load a PCA model from JSON\n   * @param {PCAModel} model\n   * @return {PCA}\n   */\n  static load(model) {\n    if (typeof model.name !== 'string') {\n      throw new TypeError('model must have a name property');\n    }\n    if (model.name !== 'PCA') {\n      throw new RangeError(`invalid model: ${model.name}`);\n    }\n    return new PCA(undefined, undefined, model);\n  }\n  /**\n   * Project the dataset into the PCA space\n   * @param {MaybeMatrix} dataset\n   * @param {PredictOptions} options\n   * @return {Matrix} dataset projected in the PCA space\n   */\n  predict(dataset, options = {}) {\n    const {\n      nComponents = this.U.columns\n    } = options;\n    let datasetmatrix;\n    if (Array.isArray(dataset)) {\n      datasetmatrix = new Matrix(dataset);\n    } else {\n      datasetmatrix = new Matrix(dataset);\n    }\n    if (this.center) {\n      datasetmatrix.subRowVector(this.means);\n      if (this.scale) {\n        for (let i of this.excludedFeatures) {\n          datasetmatrix.removeColumn(i);\n        }\n        datasetmatrix.divRowVector(this.stdevs);\n      }\n    }\n    let predictions = datasetmatrix.mmul(this.U);\n    return predictions.subMatrix(0, predictions.rows - 1, 0, nComponents - 1);\n  }\n  /**\n   * Calculates the inverse PCA transform\n   * @param {Matrix} dataset\n   * @return {Matrix} dataset projected in the PCA space\n   */\n  invert(dataset) {\n    dataset = Matrix.checkMatrix(dataset);\n    let inverse = dataset.mmul(this.U.transpose());\n    if (this.center) {\n      if (this.scale) {\n        inverse.mulRowVector(this.stdevs);\n      }\n      inverse.addRowVector(this.means);\n    }\n    return inverse;\n  }\n  /**\n   * Returns the proportion of variance for each component\n   * @return {[number]}\n   */\n  getExplainedVariance() {\n    let sum = 0;\n    if (this.S) {\n      for (const s of this.S) {\n        sum += s;\n      }\n    }\n    if (this.S) {\n      return this.S.map(value => value / sum);\n    }\n    return [];\n  }\n  /**\n   * Returns the cumulative proportion of variance\n   * @return {[number]}\n   */\n  getCumulativeVariance() {\n    let explained = this.getExplainedVariance();\n    for (let i = 1; i < explained.length; i++) {\n      explained[i] += explained[i - 1];\n    }\n    return explained;\n  }\n  /**\n   * Returns the Eigenvectors of the covariance matrix\n   * @returns {Matrix}\n   */\n  getEigenvectors() {\n    return this.U;\n  }\n  /**\n   * Returns the Eigenvalues (on the diagonal)\n   * @returns {[number]}\n   */\n  getEigenvalues() {\n    return this.S;\n  }\n  /**\n   * Returns the standard deviations of the principal components\n   * @returns {[number]}\n   */\n  getStandardDeviations() {\n    return this.S.map(x => Math.sqrt(x));\n  }\n  /**\n   * Returns the loadings matrix\n   * @return {Matrix}\n   */\n  getLoadings() {\n    return this.U.transpose();\n  }\n  /**\n   * Export the current model to a JSON object\n   * @return {Object} model\n   */\n  toJSON() {\n    return {\n      name: 'PCA',\n      center: this.center,\n      scale: this.scale,\n      means: this.means,\n      stdevs: this.stdevs,\n      U: this.U,\n      S: this.S,\n      excludedFeatures: this.excludedFeatures\n    };\n  }\n  _adjust(dataset, ignoreZeroVariance) {\n    if (this.center) {\n      const mean = dataset.mean('column');\n      const stdevs = this.scale ? dataset.standardDeviation('column', {\n        mean\n      }) : null;\n      this.means = mean;\n      dataset.subRowVector(mean);\n      if (this.scale) {\n        for (let i = 0; i < stdevs.length; i++) {\n          if (stdevs[i] === 0) {\n            if (ignoreZeroVariance) {\n              dataset.removeColumn(i);\n              stdevs.splice(i, 1);\n              this.excludedFeatures.push(i);\n              i--;\n            } else {\n              throw new RangeError(`Cannot scale the dataset (standard deviation is zero at index ${i}`);\n            }\n          }\n        }\n        this.stdevs = stdevs;\n        dataset.divRowVector(stdevs);\n      }\n    }\n  }\n  _computeFromCovarianceMatrix(dataset) {\n    const evd = new EVD(dataset, {\n      assumeSymmetric: true\n    });\n    this.U = evd.eigenvectorMatrix;\n    this.U.flipRows();\n    this.S = evd.realEigenvalues;\n    this.S.reverse();\n  }\n  _computeWithNIPALS(dataset, nCompNIPALS) {\n    this.U = new Matrix(nCompNIPALS, dataset.columns);\n    this.S = [];\n    let x = dataset;\n    for (let i = 0; i < nCompNIPALS; i++) {\n      let dc = new NIPALS(x);\n      this.U.setRow(i, dc.w.transpose());\n      this.S.push(Math.pow(dc.s.get(0, 0), 2));\n      x = dc.xResidual;\n    }\n    this.U = this.U.transpose(); // to be compatible with API\n  }\n}","map":{"version":3,"names":["Matrix","MatrixTransposeView","EVD","SVD","NIPALS","PCA","constructor","dataset","options","model","U","S","center","scale","means","stdevs","checkMatrix","R","excludedFeatures","datasetMatrix","Array","isArray","isCovarianceMatrix","method","nCompNIPALS","ignoreZeroVariance","_computeFromCovarianceMatrix","_adjust","covarianceMatrix","mmul","div","rows","_computeWithNIPALS","svd","computeLeftSingularVectors","computeRightSingularVectors","autoTranspose","rightSingularVectors","singularValues","diagonal","eigenvalues","singularValue","push","Error","load","name","TypeError","RangeError","undefined","predict","nComponents","columns","datasetmatrix","subRowVector","i","removeColumn","divRowVector","predictions","subMatrix","invert","inverse","transpose","mulRowVector","addRowVector","getExplainedVariance","sum","s","map","value","getCumulativeVariance","explained","length","getEigenvectors","getEigenvalues","getStandardDeviations","x","Math","sqrt","getLoadings","toJSON","mean","standardDeviation","splice","evd","assumeSymmetric","eigenvectorMatrix","flipRows","realEigenvalues","reverse","dc","setRow","w","pow","get","xResidual"],"sources":["/Users/balgan/Code/embeddingvisualizer/node_modules/ml-pca/src/pca.ts"],"sourcesContent":["import {\n  Matrix,\n  MatrixTransposeView,\n  EVD,\n  SVD,\n  NIPALS,\n  AbstractMatrix,\n} from 'ml-matrix';\n\ntype MaybeMatrix = AbstractMatrix | number[][];\n\nexport interface PCAOptions {\n  isCovarianceMatrix?: boolean;\n  method?: 'SVD' | 'NIPALS' | 'covarianceMatrix';\n  center?: boolean;\n  scale?: boolean;\n  nCompNIPALS?: number;\n  ignoreZeroVariance?: boolean;\n}\n\nexport interface PCAModel {\n  name: 'PCA';\n  center: boolean;\n  scale: boolean;\n  means: number[];\n  stdevs: number[];\n  U: Matrix;\n  S: number[];\n  R?: any;\n  excludedFeatures?: number[];\n}\n\nexport interface PredictOptions {\n  nComponents?: number;\n}\n\n/**\n * Creates new PCA (Principal Component Analysis) from the dataset\n * @param {MaybeMatrix} dataset - dataset or covariance matrix.\n * @param {PCAOptions} [options]\n * @param {boolean} [options.isCovarianceMatrix=false] - true if the dataset is a covariance matrix.\n * @param {string} [options.method='SVD'] - select which method to use: SVD (default), covarianceMatrirx or NIPALS.\n * @param {number} [options.nCompNIPALS=2] - number of components to be computed with NIPALS.\n * @param {boolean} [options.center=true] - should the data be centered (subtract the mean).\n * @param {boolean} [options.scale=false] - should the data be scaled (divide by the standard deviation).\n * @param {boolean} [options.ignoreZeroVariance=false] - ignore columns with zero variance if `scale` is `true`.\n * */\nexport class PCA {\n  private center: boolean;\n  private scale: boolean;\n  private excludedFeatures: number[];\n  /* eslint-disable @typescript-eslint/naming-convention */\n  private U: Matrix | null = null;\n  private S: number[] | null = null;\n  private R: any;\n  private means: number[] | null;\n  private stdevs: number[] | null;\n\n  public constructor(\n    dataset?: MaybeMatrix,\n    options: PCAOptions = {},\n    model?: PCAModel,\n  ) {\n    if (model) {\n      this.center = model.center;\n      this.scale = model.scale;\n      this.means = model.means;\n      this.stdevs = model.stdevs;\n      this.U = Matrix.checkMatrix(model.U);\n      this.S = model.S;\n      this.R = model.R;\n      this.excludedFeatures = model.excludedFeatures || [];\n      return;\n    }\n    let datasetMatrix: Matrix;\n    if (Array.isArray(dataset)) {\n      datasetMatrix = new Matrix(dataset);\n    } else {\n      datasetMatrix = new Matrix(dataset as Matrix);\n    }\n\n    const {\n      isCovarianceMatrix = false,\n      method = 'SVD',\n      nCompNIPALS = 2,\n      center = true,\n      scale = false,\n      ignoreZeroVariance = false,\n    } = options;\n\n    this.center = center;\n    this.scale = scale;\n    this.means = null;\n    this.stdevs = null;\n    this.excludedFeatures = [];\n\n    if (isCovarianceMatrix) {\n      // User provided a covariance matrix instead of dataset.\n      this._computeFromCovarianceMatrix(datasetMatrix);\n      return;\n    }\n\n    this._adjust(datasetMatrix, ignoreZeroVariance);\n    switch (method) {\n      case 'covarianceMatrix': {\n        // User provided a dataset but wants us to compute and use the covariance matrix.\n        const covarianceMatrix = new MatrixTransposeView(datasetMatrix)\n          .mmul(datasetMatrix)\n          .div(datasetMatrix.rows - 1);\n        this._computeFromCovarianceMatrix(covarianceMatrix);\n        break;\n      }\n      case 'NIPALS': {\n        this._computeWithNIPALS(datasetMatrix, nCompNIPALS);\n        break;\n      }\n      case 'SVD': {\n        const svd = new SVD(datasetMatrix, {\n          computeLeftSingularVectors: false,\n          computeRightSingularVectors: true,\n          autoTranspose: true,\n        });\n\n        this.U = svd.rightSingularVectors;\n\n        const singularValues = svd.diagonal;\n        const eigenvalues: number[] = [];\n        for (const singularValue of singularValues) {\n          eigenvalues.push(\n            (singularValue * singularValue) / (datasetMatrix.rows - 1),\n          );\n        }\n        this.S = eigenvalues;\n        break;\n      }\n      default: {\n        throw new Error(`unknown method: ${method as string}`);\n      }\n    }\n  }\n\n  /**\n   * Load a PCA model from JSON\n   * @param {PCAModel} model\n   * @return {PCA}\n   */\n  public static load(model: PCAModel): PCA {\n    if (typeof model.name !== 'string') {\n      throw new TypeError('model must have a name property');\n    }\n    if (model.name !== 'PCA') {\n      throw new RangeError(`invalid model: ${model.name as string}`);\n    }\n    return new PCA(undefined, undefined, model);\n  }\n\n  /**\n   * Project the dataset into the PCA space\n   * @param {MaybeMatrix} dataset\n   * @param {PredictOptions} options\n   * @return {Matrix} dataset projected in the PCA space\n   */\n  public predict(dataset: MaybeMatrix, options: PredictOptions = {}): Matrix {\n    const { nComponents = (this.U as Matrix).columns } = options;\n    let datasetmatrix;\n    if (Array.isArray(dataset)) {\n      datasetmatrix = new Matrix(dataset);\n    } else {\n      datasetmatrix = new Matrix(dataset);\n    }\n    if (this.center) {\n      datasetmatrix.subRowVector(this.means as number[]);\n      if (this.scale) {\n        for (let i of this.excludedFeatures) {\n          datasetmatrix.removeColumn(i);\n        }\n        datasetmatrix.divRowVector(this.stdevs as number[]);\n      }\n    }\n    let predictions = datasetmatrix.mmul(this.U as Matrix);\n    return predictions.subMatrix(0, predictions.rows - 1, 0, nComponents - 1);\n  }\n\n  /**\n   * Calculates the inverse PCA transform\n   * @param {Matrix} dataset\n   * @return {Matrix} dataset projected in the PCA space\n   */\n  public invert(dataset: Matrix): Matrix {\n    dataset = Matrix.checkMatrix(dataset);\n\n    let inverse = dataset.mmul((this.U as Matrix).transpose());\n\n    if (this.center) {\n      if (this.scale) {\n        inverse.mulRowVector(this.stdevs as number[]);\n      }\n      inverse.addRowVector(this.means as number[]);\n    }\n\n    return inverse;\n  }\n\n  /**\n   * Returns the proportion of variance for each component\n   * @return {[number]}\n   */\n  public getExplainedVariance(): number[] {\n    let sum = 0;\n    if (this.S) {\n      for (const s of this.S) {\n        sum += s;\n      }\n    }\n    if (this.S) {\n      return this.S.map((value) => value / sum);\n    }\n    return [];\n  }\n\n  /**\n   * Returns the cumulative proportion of variance\n   * @return {[number]}\n   */\n  public getCumulativeVariance(): number[] {\n    let explained = this.getExplainedVariance();\n    for (let i = 1; i < explained.length; i++) {\n      explained[i] += explained[i - 1];\n    }\n    return explained;\n  }\n\n  /**\n   * Returns the Eigenvectors of the covariance matrix\n   * @returns {Matrix}\n   */\n  public getEigenvectors(): Matrix {\n    return this.U as Matrix;\n  }\n\n  /**\n   * Returns the Eigenvalues (on the diagonal)\n   * @returns {[number]}\n   */\n  public getEigenvalues(): number[] {\n    return this.S as number[];\n  }\n\n  /**\n   * Returns the standard deviations of the principal components\n   * @returns {[number]}\n   */\n  public getStandardDeviations(): number[] {\n    return (this.S as number[]).map((x) => Math.sqrt(x));\n  }\n\n  /**\n   * Returns the loadings matrix\n   * @return {Matrix}\n   */\n  public getLoadings(): Matrix {\n    return (this.U as Matrix).transpose();\n  }\n\n  /**\n   * Export the current model to a JSON object\n   * @return {Object} model\n   */\n  public toJSON(): PCAModel {\n    return {\n      name: 'PCA',\n      center: this.center,\n      scale: this.scale,\n      means: this.means as number[],\n      stdevs: this.stdevs as number[],\n      U: this.U as Matrix,\n      S: this.S as number[],\n      excludedFeatures: this.excludedFeatures,\n    };\n  }\n\n  private _adjust(dataset: Matrix, ignoreZeroVariance: boolean) {\n    if (this.center) {\n      const mean = dataset.mean('column');\n      const stdevs = this.scale\n        ? dataset.standardDeviation('column', { mean })\n        : null;\n      this.means = mean;\n      dataset.subRowVector(mean);\n      if (this.scale) {\n        for (let i = 0; i < (stdevs as number[]).length; i++) {\n          if ((stdevs as number[])[i] === 0) {\n            if (ignoreZeroVariance) {\n              dataset.removeColumn(i);\n              (stdevs as number[]).splice(i, 1);\n              this.excludedFeatures.push(i);\n              i--;\n            } else {\n              throw new RangeError(\n                `Cannot scale the dataset (standard deviation is zero at index ${i}`,\n              );\n            }\n          }\n        }\n        this.stdevs = stdevs;\n        dataset.divRowVector(stdevs as number[]);\n      }\n    }\n  }\n\n  private _computeFromCovarianceMatrix(dataset: MaybeMatrix) {\n    const evd = new EVD(dataset as number[][], { assumeSymmetric: true });\n    this.U = evd.eigenvectorMatrix;\n    this.U.flipRows();\n    this.S = evd.realEigenvalues;\n    this.S.reverse();\n  }\n\n  private _computeWithNIPALS(dataset: Matrix, nCompNIPALS: number) {\n    this.U = new Matrix(nCompNIPALS, dataset.columns);\n    this.S = [];\n\n    let x = dataset;\n    for (let i = 0; i < nCompNIPALS; i++) {\n      let dc = new NIPALS(x);\n\n      this.U.setRow(i, dc.w.transpose());\n      this.S.push(Math.pow(dc.s.get(0, 0), 2));\n\n      x = dc.xResidual;\n    }\n    this.U = this.U.transpose(); // to be compatible with API\n  }\n}\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}